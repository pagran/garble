Index: link/internal/ld/pcln.go
<+>UTF-8
===================================================================
diff --git a/link/internal/ld/pcln.go b/link/internal/ld/pcln.go
--- a/link/internal/ld/pcln.go	(revision 5fca05073d47a02f538df8fd097ab7eda751bc0d)
+++ b/link/internal/ld/pcln.go	(date 1671738784000)
@@ -282,7 +282,7 @@
 	// For regular functions, only one returned string is nonempty.
 	// For generic functions, we use three parts so that we can print everything
 	// within the outermost "[]" as "...".
-	nameParts := func(name string) (string, string, string) {
+	_ = func(name string) (string, string, string) {
 		i := strings.IndexByte(name, '[')
 		if i < 0 {
 			return name, "", ""
@@ -301,21 +301,13 @@
 	// Write the null terminated strings.
 	writeFuncNameTab := func(ctxt *Link, s loader.Sym) {
 		symtab := ctxt.loader.MakeSymbolUpdater(s)
-		for s, off := range nameOffsets {
-			a, b, c := nameParts(ctxt.loader.SymName(s))
-			o := int64(off)
-			o = symtab.AddStringAt(o, a)
-			o = symtab.AddStringAt(o, b)
-			_ = symtab.AddCStringAt(o, c)
-		}
+		symtab.AddStringAt(0, "")
 	}

 	// Loop through the CUs, and calculate the size needed.
-	var size int64
+	var size int64 = 1
 	walkFuncs(ctxt, funcs, func(s loader.Sym) {
 		nameOffsets[s] = uint32(size)
-		a, b, c := nameParts(ctxt.loader.SymName(s))
-		size += int64(len(a) + len(b) + len(c) + 1) // NULL terminate
 	})

 	state.funcnametab = state.addGeneratedSym(ctxt, "runtime.funcnametab", size, writeFuncNameTab)
